#version 330 core

// Interpolated values from the vertex shaders
in vec2 UV;
in vec3 Position_worldspace;
in vec3 Normal_cameraspace;
in vec3 EyeDirection_cameraspace;
in vec3 LightDirection_cameraspace1;
in vec3 LightDirection_cameraspace2;
in vec3 LightDirection_cameraspace3;


// Ouput data
out vec3 color;

// Values that stay constant for the whole mesh.
uniform sampler2D myTextureSampler;
uniform mat4 MV;
uniform vec3 LightPosition_worldspace;
// Dir Light Middle
uniform vec3 dirLight_position;
uniform vec3 dirLight_ambient;
uniform vec3 dirLight_diffuse;
uniform vec3 dirLight_specular;
// Pointlight 1 left
uniform vec3 pointLights1_position;
uniform vec3 pointLights1_diffuse;
uniform vec3 pointLights1_specular;
uniform vec3 pointLights1_constant;
uniform vec3 pointLights1_linear;
uniform vec3 pointLights1_quadratic;
// Pointlight 2 right
uniform vec3 pointLights2_position;
uniform vec3 pointLights2_diffuse;
uniform vec3 pointLights2_specular;
uniform vec3 pointLights2_constant;
uniform vec3 pointLights2_linear;
uniform vec3 pointLights2_quadratic;

void main(){

	// Light emission properties
	// You probably want to put them as uniforms

	vec3 LightColor = vec3(1,1,1);
	// vec3 LightColor = vec3(1,1,1); Uebung 15
	// vec3 LightColor = vec3(0.2,0.3,0.4); Uebung 15
	
	float LightPower = 5.0f; 
	float lightPowerDirMid = 40.0f;
	float lightPowerPoint1Left = 20.0f;
	float lightPowerPoint2Right = 20.0f;
	// float LightPower = 50.0f; Uebung 15
	// float LightPower = 5.0f; Uebung 15


	// Material properties
	vec3 MaterialDiffuseColor = texture2D( myTextureSampler, UV ).rgb;
	vec3 MaterialAmbientColor = vec3(0.1,0.1,0.1) * MaterialDiffuseColor;
	vec3 MaterialSpecularColor = vec3(0.3,0.3,0.3);

	// Distance to the light
	float distance = length( LightPosition_worldspace - Position_worldspace );
	float distanceDirLight = length( dirLight_position - Position_worldspace );
	float distancePoint1 = length( pointLights1_position - Position_worldspace );
	float distancePoint2 = length( pointLights2_position - Position_worldspace );

	// Normal of the computed fragment, in camera space
	vec3 n = normalize( Normal_cameraspace );
	// Direction of the light (from the fragment to the light)
	vec3 lDirMid = normalize (LightDirection_cameraspace1);
	vec3 lPoint1Left = normalize(LightDirection_cameraspace2);
	vec3 lPoint2Right = normalize(LightDirection_cameraspace3);

	// Cosine of the angle between the normal and the light direction, 
	// clamped above 0
	//  - light is at the vertical of the triangle -> 1
	//  - light is perpendicular to the triangle -> 0
	//  - light is behind the triangle -> 0
	float cosThetaDirMid = clamp( dot( n,lDirMid ), 0,1 );
	float cosThetaPoint1Left = clamp( dot( n,lPoint1Left ), 0,1 );
	float cosThetaPoint2Right = clamp( dot( n,lPoint2Right ), 0,1 );
	
	// Eye vector (towards the camera)
	vec3 E = normalize(EyeDirection_cameraspace);
	// Direction in which the triangle reflects the light
	vec3 RDirMid = reflect(-lDirMid,n);
	vec3 RPoint1Left = reflect(-lPoint1Left,n);
	vec3 RPoint2Right = reflect(-lPoint2Right,n);
	// Cosine of the angle between the Eye vector and the Reflect vector,
	// clamped to 0
	//  - Looking into the reflection -> 1
	//  - Looking elsewhere -> < 1
	float cosAlphaDirMid = clamp( dot( E,RDirMid ), 0,1 );
	float cosAlphaPoint1Left = clamp( dot( E,RPoint1Left ), 0,1 );
	float cosAlphaPoint2Right = clamp( dot( E,RPoint2Right ), 0,1 );
	
	color = 
		// Ambient : simulates indirect lighting
		MaterialAmbientColor +
		// Diffuse : "color" of the object
		MaterialDiffuseColor * dirLight_diffuse * lightPowerDirMid * cosThetaDirMid / (distanceDirLight*distanceDirLight) +
		// Specular : reflective highlight, like a mirror
		MaterialSpecularColor * dirLight_diffuse * LightPower * pow(cosAlphaDirMid,5) / (distanceDirLight*distanceDirLight) +
		// Diffuse : "color" of the object
		MaterialDiffuseColor * pointLights1_diffuse *  lightPowerPoint1Left * cosThetaPoint1Left / (distancePoint1*distancePoint1) +
		// Specular : reflective highlight, like a mirror
		MaterialSpecularColor * pointLights1_diffuse * LightPower * pow(cosAlphaPoint1Left,5) / (distancePoint1*distancePoint1) +
		// Diffuse : "color" of the object
		MaterialDiffuseColor * pointLights2_diffuse *  lightPowerPoint2Right * cosThetaPoint2Right / (distancePoint2*distancePoint2) +
		// Specular : reflective highlight, like a mirror
		MaterialSpecularColor * pointLights2_diffuse * LightPower * pow(cosAlphaPoint2Right,5) / (distancePoint2*distancePoint2)
		;

}